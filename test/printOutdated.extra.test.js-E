/**
 * Tests for printOutdated extra table and xml output cases
 * @story prompts/001.0-DEV-RUN-NPM-OUTDATED.md
 * @story prompts/002.0-DEV-FETCH-VERSION-AGES.md
 * @story prompts/003.0-DEV-FILTER-MATURE-VERSIONS.md
 * @story prompts/004.0-DEV-FILTER-VULNERABLE-VERSIONS.md
 * @story prompts/009.0-DEV-XML-OUTPUT.md
 * @req REQ-OUTPUT-DISPLAY - Display table output correctly for outdated packages
 * @req REQ-FETCH-ERROR-HANDLING - Warn and fallback when fetchVersionTimes fails
 * @req REQ-XML-FILTER - Mark filtered entries in XML output for security filtering
 */

import { vi, describe, test, expect, beforeEach, afterEach } from 'vitest';
import { printOutdated } from '../src/print-outdated.js';

// Table output normal case
describe('printOutdated unit tests - table output normal case', () => {
  let logSpy;
  let errorSpy;

  beforeEach(() => {
    logSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    errorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => vi.restoreAllMocks());

  test('single entry above age threshold and no vulnerabilities prints row without errors', async () => {
    const data = {
      pkgN: { current: '4.0.0', wanted: '4.1.0', latest: '4.1.0' },
    };
    const fetchStub = vi.fn().mockResolvedValue({ '4.1.0': '2020-01-01T00:00:00.000Z' });
    const ageStub = vi.fn().mockReturnValue(30);
    const vulnStub = vi.fn().mockResolvedValue(0);
    await printOutdated(data, {
      format: 'table',
      fetchVersionTimes: fetchStub,
      calculateAgeInDays: ageStub,
      checkVulnerabilities: vulnStub,
      prodMinAge: 7,
      devMinAge: 7,
    });
    expect(errorSpy).not.toHaveBeenCalled();
    expect(logSpy).toHaveBeenCalledWith('Outdated packages:');
    expect(logSpy).toHaveBeenCalledWith(['Name', 'Current', 'Wanted', 'Latest', 'Age (days)', 'Type'].join('	'));
    expect(logSpy).toHaveBeenCalledWith('pkgN	4.0.0	4.1.0	4.1.0	30	dev');
  });
});

// Table output fetch error branch
describe('printOutdated unit tests - table fetch error branch', () => {
  let logSpy;
  let errorSpy;

  beforeEach(() => {
    logSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    errorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => vi.restoreAllMocks());

  test('fetchVersionTimes rejects leads to warning and mature filter message', async () => {
    const data = {
      pkgD: { current: '5.0.0', wanted: '5.1.0', latest: '5.1.0' },
    };
    const fetchStub = vi.fn().mockRejectedValue(new Error('fetch fail'));
    const ageStub = vi.fn();
    const vulnStub = vi.fn();
    await printOutdated(data, {
      format: 'table',
      fetchVersionTimes: fetchStub,
      calculateAgeInDays: ageStub,
      checkVulnerabilities: vulnStub,
      prodMinAge: 7,
      devMinAge: 7,
    });
    expect(errorSpy).toHaveBeenCalledWith(
      expect.stringContaining('Warning: failed to fetch version times for pkgD: fetch fail')
    );
    expect(ageStub).not.toHaveBeenCalled();
    expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('No outdated packages with mature versions found'));
  });
});

// XML vulnerability filter
describe('printOutdated unit tests - xml output vulnerability filter', () => {
  let logSpy;

  beforeEach(() => {
    logSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
  });

  afterEach(() => vi.restoreAllMocks());

  test('single entry with vulnerabilities in xml output marked as filtered security', async () => {
    const data = {
      pkgV: { current: '6.0.0', wanted: '6.1.0', latest: '6.1.0' },
    };
    const fetchStub = vi.fn().mockResolvedValue({ '6.1.0': '2020-01-01T00:00:00.000Z' });
    const ageStub = vi.fn().mockReturnValue(20);
    const vulnStub = vi.fn().mockResolvedValue(2);
    const summary = await printOutdated(data, {
      format: 'xml',
      fetchVersionTimes: fetchStub,
      calculateAgeInDays: ageStub,
      checkVulnerabilities: vulnStub,
      prodMinAge: 7,
      devMinAge: 7,
    });
    expect(summary.filteredBySecurity).toBe(1);
    const output = logSpy.mock.calls[0][0];
    expect(output).toContain('<filtered>true</filtered>');
    expect(output).toContain('<filter-reason>security</filter-reason>');
  });
});
