# 002.2-SDLC-CLI-TESTING: CLI integration testing

## Release Goal

**CLI Development Automation: Step 3 - Testing & Quality**

Automate testing of actual CLI commands and their output. Ensures the CLI works correctly from the user's perspective by testing real command execution.

## How This Story Contributes

Provides confidence that CLI commands work correctly in real usage scenarios. Catches issues that unit tests might miss, such as argument parsing problems, output formatting issues, or environment-specific bugs.

## User Story

**Format**: So that I can ensure the CLI works correctly for end users, as a developer, I want automated tests that execute actual CLI commands and validate their output.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented using execa + vitest without dependencies
- **Negotiable**: Test scenarios and assertion methods can be customized
- **Valuable**: Provides end-to-end confidence in CLI functionality
- **Estimable**: Clear scope - CLI execution testing framework
- **Small**: Can be completed in 1-2 sessions (M effort)
- **Testable**: Clear success criteria - CLI commands can be tested programmatically

## Acceptance Criteria

- [ ] **CLI Execution**: Tests can spawn CLI processes and capture output
- [ ] **Output Validation**: Tests can assert on stdout, stderr, and exit codes
- [ ] **Argument Testing**: Tests can validate different command-line arguments
- [ ] **Error Scenarios**: Tests can validate error handling and error messages
- [ ] **Integration Setup**: Tests run in isolated environments to avoid interference

## Requirements (Current Implementation or To Be Implemented)

- **REQ-PROCESS-SPAWN**: Use execa to spawn CLI processes in tests
- **REQ-OUTPUT-CAPTURE**: Capture and validate stdout/stderr output
- **REQ-ISOLATION**: Ensure tests don't interfere with each other
- **REQ-REALISTIC-SCENARIOS**: Test real-world usage patterns

## Dependencies

- Basic CLI structure exists
- vitest testing framework is set up
- execa package for process execution

## Implementation Notes

**Technical Considerations**:
- Use execa for reliable cross-platform process execution
- Create test fixtures for different package.json scenarios
- Use temporary directories to isolate test environments
- Consider both success and failure scenarios

**Test Framework Setup**:

`test/helpers/cli-helper.js`:
```javascript
import { execa } from 'execa';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __dirname = dirname(fileURLToPath(import.meta.url));
const CLI_PATH = join(__dirname, '../../bin/dry-aged-deps');

export async function runCLI(args = [], options = {}) {
  try {
    const result = await execa('node', [CLI_PATH, ...args], {
      cwd: options.cwd || process.cwd(),
      stdio: 'pipe',
      ...options,
    });
    return { 
      stdout: result.stdout,
      stderr: result.stderr,
      exitCode: result.exitCode,
      success: true 
    };
  } catch (error) {
    return {
      stdout: error.stdout || '',
      stderr: error.stderr || '',
      exitCode: error.exitCode || 1,
      success: false,
      error
    };
  }
}
```

**Example Test**:
```javascript
import { describe, it, expect } from 'vitest';
import { runCLI } from './helpers/cli-helper.js';

describe('CLI Integration', () => {
  it('shows help when --help flag is used', async () => {
    const result = await runCLI(['--help']);
    
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Usage:');
    expect(result.exitCode).toBe(0);
  });

  it('handles invalid commands gracefully', async () => {
    const result = await runCLI(['invalid-command']);
    
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('Unknown command');
    expect(result.exitCode).toBe(1);
  });
});
```

**Testing Strategy**:
- Test help output and version commands
- Test main functionality with sample package.json files
- Test error scenarios and edge cases
- Test different argument combinations

## Definition of Done

- [ ] All acceptance criteria met
- [ ] CLI helper utility created for test reuse
- [ ] Test cases cover main CLI commands
- [ ] Error scenarios are tested and validated
- [ ] Tests run reliably in CI environment
- [ ] Documentation explains how to add new CLI tests

---

## Story Notes

**WSJF Score**: 10 (Size: M=3, Business Value: High=3, Time Criticality: Medium=2, Risk Reduction: High=3)

**Implementation Approach**: Use execa + vitest for reliable CLI process testing rather than building custom test harness.

**Next Evolution**: Future stories can add performance testing, cross-platform validation, and user workflow testing.